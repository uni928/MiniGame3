<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>å®Œå…¨ã«éš ã™ã‚²ãƒ¼ãƒ ï¼ˆ5ãƒ©ã‚¦ãƒ³ãƒ‰ãƒ»ä¸­å¤®å€¤ã‚¹ã‚³ã‚¢ï¼‰</title>
<style>
  :root {
    --board-w: 780px; /* 16:9 ã®æ¨ªé•·ãƒ‡ãƒ•ã‚© */
    --board-h: 438px;
    --cover-radius: 60; /* pxï¼ˆã‚¯ãƒªãƒƒã‚¯ã§å‡ºã‚‹å††ã®åŠå¾„ï¼‰*/
    --emoji-size: 28px; /* çµµæ–‡å­—ã®ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º */
    --bg: #f7f7fb;
    --ink: #111;
    --muted: #6b7280;
    --accent: #2563eb;
  }
  * { box-sizing: border-box; }
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
    margin: 0; padding: 24px; color: var(--ink); background: linear-gradient(180deg, #ffffff, #f5f7ff);
  }
  h1 { font-size: 20px; margin: 0 0 8px; }
  .app {
    max-width: 980px; margin: 0 auto; display: grid; gap: 16px;
    grid-template-columns: 1fr;
  }
  .panel {
    background: #fff; border: 1px solid #e5e7eb; border-radius: 16px; padding: 14px 16px; box-shadow: 0 6px 20px rgba(0,0,0,0.06);
  }
  .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
  .spacer { flex: 1; }
  .stat { color: var(--muted); font-size: 14px; }
  .stat strong { color: var(--ink); font-weight: 600; }
  button {
    appearance: none; border: 1px solid #d1d5db; background: #fff; color: var(--ink);
    border-radius: 999px; padding: 10px 16px; cursor: pointer; font-weight: 600; transition: 0.15s ease;
  }
  button:hover { border-color: var(--accent); box-shadow: 0 4px 14px rgba(37,99,235,0.15); }
  button.primary { background: var(--accent); color: #fff; border-color: var(--accent); }
  button:disabled { opacity: 0.5; cursor: not-allowed; }
  .board-wrap { display: grid; gap: 10px; }
  .board {
    position: relative; width: 100%; max-width: var(--board-w); aspect-ratio: 16/9;
    background: var(--bg); border: 2px dashed #cbd5e1; border-radius: 18px; overflow: hidden; margin: 0 auto;
    user-select: none; touch-action: manipulation;
  }
  .emoji {
    position: absolute; font-size: var(--emoji-size); line-height: 1; transform: translate(-50%, -50%);
    filter: drop-shadow(0 1px 0 #fff);
  }
  /* ã‚«ãƒãƒ¼æ¸ˆã¿ã®å¼·èª¿è¡¨ç¤º */
  .emoji.covered {
    background: rgba(34,197,94,0.12); /* green-500 ã®è–„ã„èƒŒæ™¯ */
    outline: 2px solid #22c55e; /* green-500 */
    border-radius: 999px;
    padding: 2px 4px;
    transform: translate(-50%, -50%) scale(1.08);
  }
  .emoji.just {
    animation: pop 0.35s ease;
  }
   .emoji.uncovered {
     background: rgba(250,204,21,0.18); /* amber-400 è–„ã‚ */
     outline: 2px dashed #f59e0b;       /* amber-500 */
     border-radius: 8px;
     padding: 1px 3px;
     animation: blink 0.9s ease-in-out infinite alternate;
   }
  @keyframes pop {
    0% { transform: translate(-50%, -50%) scale(0.85); }
    60% { transform: translate(-50%, -50%) scale(1.20); }
    100% { transform: translate(-50%, -50%) scale(1.08); }
  }
   @keyframes blink {
     from { filter: brightness(1); }
     to   { filter: brightness(1.25); }
   }
  .legend { font-size: 13px; color: var(--muted); }
  .rounds { display: flex; gap: 8px; flex-wrap: wrap; }
  .chip {
    border: 1px solid #e5e7eb; padding: 6px 10px; border-radius: 12px; background: #fff; font-size: 13px; color: #111;
  }
  .chip.done { background: #eef2ff; border-color: #c7d2fe; }
  .chip.now { background: #dcfce7; border-color: #86efac; }
  .chip .small { color: var(--muted); font-size: 12px; }
  canvas { position: absolute; inset: 0; display: block; }
</style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <div class="row">
        <h1>å®Œå…¨ã«éš ã™ã‚²ãƒ¼ãƒ </h1>
        <div class="spacer"></div>
        <button id="startBtn" class="primary">ã‚²ãƒ¼ãƒ é–‹å§‹ / ãƒªã‚»ãƒƒãƒˆ</button>
        <button id="nextBtn" disabled>æ¬¡ã®ãƒ©ã‚¦ãƒ³ãƒ‰</button>
         <button id="highlightBtn">æœªã‚«ãƒãƒ¼å¼·èª¿</button>
      </div>
      <div class="row" style="margin-top:8px; gap:20px;">
        <div class="stat">ãƒ©ã‚¦ãƒ³ãƒ‰: <strong id="roundLabel">- / 5</strong></div>
        <div class="stat">ã‚¯ãƒªãƒƒã‚¯å›æ•°: <strong id="clicksLabel">0</strong></div>
        <div class="stat">æœªã‚«ãƒãƒ¼çµµæ–‡å­—: <strong id="remainLabel">-</strong></div>
        <div class="stat">åŠå¾„: <strong id="radiusLabel">60px</strong></div>
      </div>
      <div class="board-wrap" style="margin-top:8px;">
        <div id="board" class="board"></div>
        <div class="legend">ç›¤é¢ã‚’ã‚¯ãƒªãƒƒã‚¯ <em>ã¾ãŸã¯ãƒ‰ãƒ©ãƒƒã‚°</em> ã™ã‚‹ã¨ã€Œéš ã™å††ã€ãŒç¾ã‚Œã¾ã™ã€‚ãƒ‰ãƒ©ãƒƒã‚°ã§åŠå¾„ã‚’èª¿æ•´å¯èƒ½ï¼ˆã‚¯ãƒªãƒƒã‚¯ã®ã¿ã®å ´åˆã¯æ—¢å®šåŠå¾„ï¼‰ã€‚å††ã®<strong>å†…å´ã«å®Œå…¨ã«å…¥ã£ãŸçµµæ–‡å­—</strong>ã¯è‡ªå‹•ã§å¼·èª¿è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚å…¨ã¦éš ã—ãŸã‚‰ãƒ©ã‚¦ãƒ³ãƒ‰ã‚¯ãƒªã‚¢ï¼ˆå…¨5ãƒ©ã‚¦ãƒ³ãƒ‰ã€ä¸­å¤®å€¤ã§ã‚¹ã‚³ã‚¢ï¼‰ã€‚</div>
      </div>
    </div>

    <div class="panel">
      <div class="row" style="justify-content:space-between; align-items:flex-start;">
        <div>
          <div style="font-weight:700; margin-bottom:8px;">ãƒ©ã‚¦ãƒ³ãƒ‰çµæœ</div>
          <div class="rounds" id="rounds"></div>
        </div>
        <div>
          <div class="stat">ä¸­å¤®å€¤ã‚¹ã‚³ã‚¢: <strong id="medianScore">-</strong></div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ====== å¯å¤‰ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ ======
  const TOTAL_ROUNDS = 3;
  const EMOJIS_PER_ROUND = 80;            // 1ãƒ©ã‚¦ãƒ³ãƒ‰ã®çµµæ–‡å­—æ•°
  const COVER_RADIUS = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cover-radius')) || 60;
  const EMOJI_SIZE = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--emoji-size')) || 28; // px
  const EMOJI_RADIUS = Math.ceil(EMOJI_SIZE / 2); // å®Œå…¨ã‚«ãƒãƒ¼åˆ¤å®šã«ä½¿ã†åŠå¾„è¿‘ä¼¼
  const EMOJI_POOL = [
    'ğŸ','ğŸŠ','ğŸ‹','ğŸ‰','ğŸ‡','ğŸ“','ğŸ’','ğŸ‘','ğŸ¥','ğŸ','ğŸ¥¥','ğŸ¥‘',
    'ğŸŒ¸','ğŸŒ¼','ğŸŒ»','ğŸŒ¹','ğŸŒ·','ğŸ€','ğŸŒ´','ğŸŒµ','ğŸ','ğŸ„','â­','âœ¨',
    'ğŸ¶','ğŸ±','ğŸ­','ğŸ¹','ğŸ°','ğŸ¦Š','ğŸ»','ğŸ¼','ğŸ¸','ğŸµ',
    'âš½','ğŸ€','ğŸˆ','ğŸ¾','ğŸ²','ğŸ§©','ğŸ¯','ğŸ¨','ğŸµ','ğŸ§'
  ];

  // è¦–èªç”¨ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³è¡¨ç¤ºã®å®šæ•°
  const OUTLINE_WIDTH = 2;                     // å††ã®æ ç·šã®å¤ªã•
  const OUTLINE_COLOR = 'rgba(0,0,0,0.35)';    // å††ã®æ ç·šã®è‰²ï¼ˆåŠé€æ˜ï¼‰
  const SHADOW_BLUR = 8;                       // ã»ã‚“ã®å°‘ã—ã®å½±ã§è¦‹ã‚„ã™ã
  const SHADOW_COLOR = 'rgba(0,0,0,0.15)';

  // ãƒ‰ãƒ©ãƒƒã‚°ã§ã‚µã‚¤ã‚ºå¯å¤‰
  const R_MIN = 30;          // æœ€å°åŠå¾„
  const R_MAX = 220;         // æœ€å¤§åŠå¾„
  const PREVIEW_DASH = [6,6];// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å††ã®ç ´ç·š
  const PREVIEW_COLOR = 'rgba(37,99,235,0.7)'; // æ¿ƒã„ã‚ã®ã‚¢ã‚¯ã‚»ãƒ³ãƒˆ

  // ====== DOM å‚ç…§ ======
  const board = document.getElementById('board');
  const startBtn = document.getElementById('startBtn');
  const nextBtn = document.getElementById('nextBtn');
  const highlightBtn = document.getElementById('highlightBtn');
  const roundLabel = document.getElementById('roundLabel');
  const clicksLabel = document.getElementById('clicksLabel');
  const remainLabel = document.getElementById('remainLabel');
  const roundsDiv = document.getElementById('rounds');
  const medianScoreEl = document.getElementById('medianScore');
  const radiusLabel = document.getElementById('radiusLabel');
  radiusLabel.textContent = COVER_RADIUS + 'px';

  // ====== ã‚­ãƒ£ãƒ³ãƒã‚¹ï¼ˆä¸Šã«é‡ã­ã¦éš ã™å††ã‚’æãï¼‰ ======
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 10; canvas.height = 10; // åˆæœŸ
  board.appendChild(canvas);

  // ä¸‹å±¤ã«çµµæ–‡å­—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆHTMLï¼‰ã€ä¸Šå±¤ã«ã‚«ãƒãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆCanvasï¼‰

  // ====== çŠ¶æ…‹ ======
  let roundIndex = 0; // 0..TOTAL_ROUNDS-1
  let clickCount = 0;
  let coverCircles = []; // {x, y, r}
  let emojis = []; // {x, y, el}
  let results = []; // å„ãƒ©ã‚¦ãƒ³ãƒ‰ã®ã‚¯ãƒªãƒƒã‚¯å›æ•°
  let playing = false;
  let tempCircle = null;
  let isDrawing = false;
  let startPt = null;
  let highlightUncovered = false; // æœªã‚«ãƒãƒ¼å¼·èª¿ãƒˆã‚°ãƒ«

  // ãƒ‡ãƒã‚¤ã‚¹ãƒ”ã‚¯ã‚»ãƒ«æ¯”ã«åˆã‚ã›ã¦ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¹ã‚±ãƒ¼ãƒ«
  function fitCanvasToBoard() {
    const rect = board.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // è«–ç†åº§æ¨™=CSS px
    redrawCovers();
  }

  function redrawCovers() {
    // ç›¤é¢èƒŒæ™¯è‰²ã§å††ã‚’å¡—ã‚Šã¤ã¶ã—ã¦â€œéš ã™â€ + å¯è¦–åŒ–ã®ãŸã‚ã«æ ç·šã‚’æç”»
    const style = getComputedStyle(document.documentElement);
    const bg = style.getPropertyValue('--bg').trim() || '#f7f7fb';
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    for (const c of coverCircles) {
      // å¡—ã‚Šï¼ˆéš ã™å‡¦ç†ï¼‰
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
      ctx.fillStyle = bg;
      ctx.fill();

      // ã»ã‚“ã®ã‚Šå½±
      ctx.save();
      ctx.shadowBlur = SHADOW_BLUR;
      ctx.shadowColor = SHADOW_COLOR;

      // æ ç·šï¼ˆè¦–èªç”¨ï¼‰
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
      ctx.lineWidth = OUTLINE_WIDTH;
      ctx.strokeStyle = OUTLINE_COLOR;
      ctx.stroke();
      ctx.restore();
    }

    // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
    if (tempCircle) {
      ctx.save();
      ctx.setLineDash(PREVIEW_DASH);
      ctx.beginPath();
      ctx.arc(tempCircle.x, tempCircle.y, tempCircle.r, 0, Math.PI * 2);
      ctx.lineWidth = 2;
      ctx.strokeStyle = PREVIEW_COLOR;
      ctx.stroke();
      ctx.restore();
    }
  }

  function randomEmoji() {
    return EMOJI_POOL[Math.floor(Math.random() * EMOJI_POOL.length)];
  }

  function spawnEmojis() {
    // æ—¢å­˜ã‚’ã‚¯ãƒªã‚¢
    for (const e of emojis) e.el.remove();
    emojis = [];

    const rect = board.getBoundingClientRect();
    const pad = EMOJI_RADIUS + 6; // ç«¯ã«ã‚ã‚Šè¾¼ã¾ãªã„ã‚ˆã†ã«ä½™ç™½
    for (let i = 0; i < EMOJIS_PER_ROUND; i++) {
      const x = Math.random() * (rect.width - pad * 2) + pad;
      const y = Math.random() * (rect.height - pad * 2) + pad;
      const el = document.createElement('span');
      el.className = 'emoji';
      el.textContent = randomEmoji();
      el.style.left = x + 'px';
      el.style.top = y + 'px';
      el.style.fontSize = EMOJI_SIZE + 'px';
      board.appendChild(el);
      emojis.push({ x, y, el });
    }
    updateRemain();
  }

  function updateRemain() {
    const covered = emojis.filter(isEmojiFullyCovered).length;
    remainLabel.textContent = (emojis.length - covered).toString();
    updateCoverageStyles();
  }

  function isEmojiFullyCovered(emoji) {
    // ã„ãšã‚Œã‹ã®å††ã§å®Œå…¨ã‚«ãƒãƒ¼: ä¸­å¿ƒã‹ã‚‰ã®è·é›¢ + çµµæ–‡å­—åŠå¾„ <= å††åŠå¾„
    for (const c of coverCircles) {
      const dx = emoji.x - c.x;
      const dy = emoji.y - c.y;
      const dist = Math.hypot(dx, dy);
      if (dist + EMOJI_RADIUS <= c.r) return true;
    }
    return false;
  }

  function allCovered() {
    return emojis.every(isEmojiFullyCovered);
  }

  function updateCoverageStyles() {
    // ã‚«ãƒãƒ¼çŠ¶æ…‹ã«å¿œã˜ã¦å¼·èª¿ã‚¯ãƒ©ã‚¹ã‚’ä»˜ã‘å¤–ã—
    for (const e of emojis) {
      const now = isEmojiFullyCovered(e);
      const had = e._covered || false;
      e._covered = now;
      if (now) {
        if (!had) {
          e.el.classList.add('covered', 'just');
          // ã‚¢ãƒ‹ãƒ¡å¾Œã«justã ã‘å¤–ã™
          setTimeout(() => e.el.classList.remove('just'), 400);
        } else {
          e.el.classList.add('covered');
        }
      } else {
        e.el.classList.remove('covered', 'just');
      }
       // æœªã‚«ãƒãƒ¼å¼·èª¿ã®ä»˜ã‘å¤–ã—
       if (!now && highlightUncovered) {
         e.el.classList.add('uncovered');
       } else {
         e.el.classList.remove('uncovered');
       }
    }
  }

   // æœªã‚«ãƒãƒ¼å¼·èª¿ãƒˆã‚°ãƒ«
   highlightBtn.addEventListener('click', () => {
     highlightUncovered = !highlightUncovered;
     // ãƒœã‚¿ãƒ³è¦‹ãŸç›®ã®ãƒˆã‚°ãƒ«ï¼ˆONæ™‚ã¯å¼·èª¿ï¼‰
     highlightBtn.classList.toggle('primary', highlightUncovered);
     highlightBtn.textContent = highlightUncovered ? 'æœªã‚«ãƒãƒ¼å¼·èª¿: ON' : 'æœªã‚«ãƒãƒ¼å¼·èª¿';
     updateCoverageStyles();
   });

  function setPlayingState(isPlaying) {
    playing = isPlaying;
    nextBtn.disabled = true;
  }
  function startRound(idx) {
    roundIndex = idx;
    clickCount = 0;
    coverCircles = [];
    fitCanvasToBoard();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    spawnEmojis();
   for (const e of emojis) e._covered = false; // çŠ¶æ…‹åˆæœŸåŒ–
   updateRemain();          // æ®‹ã‚Šçµµæ–‡å­—æ•°æ›´æ–°
   isDrawing = false;       // ãƒ©ã‚¦ãƒ³ãƒ‰é–‹å§‹æ™‚ã¯ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œãªã—
   startPt = null;
   tempCircle = null;
   redrawCovers();          // ç›¤é¢åˆæœŸåŒ–æç”»
   clicksLabel.textContent = '0';
   roundLabel.textContent = `${idx + 1} / ${TOTAL_ROUNDS}`;
   setPlayingState(true);
   renderResults();
  }


  board.addEventListener('mousemove', (ev) => {
    if (!isDrawing || !playing) return;
    const rect = board.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    const r = clamp(Math.hypot(x - startPt.x, y - startPt.y), R_MIN, R_MAX);
    tempCircle = { x: startPt.x, y: startPt.y, r };
    redrawCovers();
    updateRemain();
  });

  board.addEventListener('mouseup', (ev) => {
    if (!playing) return;
    const rect = board.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;

    let r = 0;
    if (isDrawing && tempCircle) {
      r = tempCircle.r;
    }
    // ã‚¯ãƒªãƒƒã‚¯ã®ã¿ï¼ˆãƒ‰ãƒ©ãƒƒã‚°è·é›¢ã»ã¼0ï¼‰ã®å ´åˆã¯æ—¢å®šåŠå¾„
    if (!isDrawing || r < R_MIN * 0.5) {
      coverCircles.push({ x, y, r: COVER_RADIUS });
    } else {
      coverCircles.push({ x: startPt.x, y: startPt.y, r });
    }

    isDrawing = false;
    startPt = null;
    tempCircle = null;

    clickCount++;
    clicksLabel.textContent = String(clickCount);
    redrawCovers();
    updateRemain();
    if (allCovered()) {
      endRound();
    }
  });

  function endRound() {
   // ãƒ©ã‚¦ãƒ³ãƒ‰çµ‚äº†ï¼šçŠ¶æ…‹ã¨çµæœã‚’ç¢ºå®š
    setPlayingState(false);
    results[roundIndex] = clickCount;
    renderResults();
    updateRemain();      // æœ€çµ‚çš„ã«æœªã‚«ãƒãƒ¼0ã®ã¯ãšã ãŒUIåŒæœŸã®ãŸã‚
    redrawCovers();      // å††ã‚’æ®‹ã—ãŸã¾ã¾è¦‹ãŸç›®ã‚’å›ºå®š

   // æ¬¡ãƒ©ã‚¦ãƒ³ãƒ‰é·ç§»å¯å¦
    if (roundIndex < TOTAL_ROUNDS - 1) {
      nextBtn.disabled = false;
    } else {
      nextBtn.disabled = true;
      roundLabel.textContent = `å®Œäº† / ${TOTAL_ROUNDS}`;
    }
  }


  // ç›¤å¤–ã§ã®ãƒã‚¦ã‚¹ã‚¢ãƒƒãƒ—å¯¾ç­–
document.addEventListener('mouseup', (ev) => {
    if (isDrawing) {
     isDrawing = false;
     startPt = null;
     tempCircle = null;
     redrawCovers();
     updateRemain();
    }
  });

  // ãƒªã‚µã‚¤ã‚ºæ™‚ã®ã‚­ãƒ£ãƒ³ãƒã‚¹å†ãƒ•ã‚£ãƒƒãƒˆ
  const ro = new ResizeObserver(() => fitCanvasToBoard());
  ro.observe(board);
  window.addEventListener('orientationchange', fitCanvasToBoard);

  // ãƒœã‚¿ãƒ³
  startBtn.addEventListener('click', () => {
    results = new Array(TOTAL_ROUNDS).fill(null);
    renderResults();
    startRound(0);
  });

  nextBtn.addEventListener('click', () => {
    if (roundIndex < TOTAL_ROUNDS - 1) {
      startRound(roundIndex + 1);
    }
  });

  function renderResults() {
    roundsDiv.innerHTML = '';
    for (let i = 0; i < TOTAL_ROUNDS; i++) {
      const chip = document.createElement('div');
      chip.className = 'chip' + 
        (i === roundIndex && playing
          ? ' now'
          : results[i] != null
          ? ' done'
          : '');
      chip.innerHTML = `R${i + 1}: <span class="small">${
        results[i] != null ? results[i] + ' å›' : (i < roundIndex ? 'æœªè¨˜éŒ²' : 'å¾…æ©Ÿ')
      }</span>`;
      roundsDiv.appendChild(chip);
    }

    const filled = results.filter((v) => typeof v === 'number');
    const m = filled.length === TOTAL_ROUNDS ? median(filled) : null;
    medianScoreEl.textContent = m != null ? m + ' å›' : '-';
  }

  function median(arr) {
    if (!arr || arr.length === 0) return null;
    const sorted = arr.slice().sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted[mid];
  }

  // åˆæœŸæç”»
  fitCanvasToBoard();
  renderResults();
})();
</script>
</body>
</html>
